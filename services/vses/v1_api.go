
/*
 * api
 *
 * Search Engine Service(VPC) Open API<br/>https://vpcsearchengine.apigw.ntruss.com/api/v1
 *
 * API version: 2022-04-21T09:07:51Z
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package vses

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type V1ApiService service

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param changeCountOfDataNode 데이터 노드 추가 파라미터
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) ClusterChangeCountOfDataNodeServiceGroupInstanceNoPost(ctx context.Context, changeCountOfDataNode AddNodesInCluster, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/changeCountOfDataNode/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &changeCountOfDataNode

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param createCluster 클러스터 생성 파라미터
 * @param xNCPREGIONNO Region No

@return ResponseVoCreateClusterResponseVo
*/
func (a *V1ApiService) ClusterCreateElasticsearchClusterPost(ctx context.Context, createCluster CreateCluster, xNCPREGIONNO int32) (ResponseVoCreateClusterResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoCreateClusterResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/createElasticsearchCluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &createCluster

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) ClusterDeleteElasticsearchClusterServiceGroupInstanceNoDelete(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/deleteElasticsearchCluster/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoGetOpenApiAcgInfoList
*/
func (a *V1ApiService) ClusterGetAcgInfoListServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoGetOpenApiAcgInfoList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetOpenApiAcgInfoList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getAcgInfoList/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoGetOpenApiServiceGroupResponseVo
*/
func (a *V1ApiService) ClusterGetClusterDataNodeListServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoGetOpenApiServiceGroupResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetOpenApiServiceGroupResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getClusterDataNodeList/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterInfoRequest 클러스터 조회 시 사용되는 파라미터
 * @param xNCPREGIONNO Region No

@return ResponseVoOpenApiGetClusterInfoListResponseVo
*/
func (a *V1ApiService) ClusterGetClusterInfoListPost(ctx context.Context, clusterInfoRequest GetClusterRequest, xNCPREGIONNO int32) (ResponseVoOpenApiGetClusterInfoListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoOpenApiGetClusterInfoListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getClusterInfoList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &clusterInfoRequest

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xNCPREGIONNO Region No

@return ResponseVoGetElasticSearchVersionListResponseVo
*/
func (a *V1ApiService) ClusterGetElasticsearchVersionListGet(ctx context.Context, xNCPREGIONNO int32) (ResponseVoGetElasticSearchVersionListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetElasticSearchVersionListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getElasticsearchVersionList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xNCPREGIONNO Region No

@return ResponseVoGetOpenApiLoginKeyListResponseVo
*/
func (a *V1ApiService) ClusterGetLoginKeyListGet(ctx context.Context, xNCPREGIONNO int32) (ResponseVoGetOpenApiLoginKeyListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetOpenApiLoginKeyListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getLoginKeyList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param getNodeProductList HW 상품 스펙 조회 파라미터
 * @param xNCPREGIONNO Region No

@return ResponseVoGetOpenApiHwProductListResponseVo
*/
func (a *V1ApiService) ClusterGetNodeProductListPost(ctx context.Context, getNodeProductList NodeProduct, xNCPREGIONNO int32) (ResponseVoGetOpenApiHwProductListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetOpenApiHwProductListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getNodeProductList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &getNodeProductList

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xNCPREGIONNO Region No

@return ResponseVoGetOpenApiOsProductListResponseVo
*/
func (a *V1ApiService) ClusterGetOsProductListGet(ctx context.Context, xNCPREGIONNO int32) (ResponseVoGetOpenApiOsProductListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetOpenApiOsProductListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getOsProductList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param getSubnetList Subnet 목록 조회
 * @param xNCPREGIONNO Region No

@return ResponseVoGetVpcSubnetListResponseVo
*/
func (a *V1ApiService) ClusterGetSubnetListPost(ctx context.Context, getSubnetList GetSubnetList, xNCPREGIONNO int32) (ResponseVoGetVpcSubnetListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetVpcSubnetListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getSubnetList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &getSubnetList

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xNCPREGIONNO Region No

@return ResponseVoGetVpcConfigListResponseVo
*/
func (a *V1ApiService) ClusterGetVpcListGet(ctx context.Context, xNCPREGIONNO int32) (ResponseVoGetVpcConfigListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetVpcConfigListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/getVpcList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param kibanaPassword 키바나 패스워드 변경
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) ClusterResetKibanaPasswordServiceGroupInstanceNoPost(ctx context.Context, kibanaPassword ResetKibanaPassword, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/resetKibanaPassword/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &kibanaPassword

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) ClusterRestartElasticsearchClusterServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/restartElasticsearchCluster/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No
 * @param optional nil or *V1ApiDashboardGetDashboardInformationServiceGroupInstanceNoGetOpts - Optional Parameters:
     * @param "PageNo" (optional.Int32) -  pageNo
     * @param "PageSize" (optional.Int32) -  pageSize

@return ResponseVoGetOpenApiDashboardInformationResponseVo
*/

type V1ApiDashboardGetDashboardInformationServiceGroupInstanceNoGetOpts struct { 
	PageNo optional.Int32
	PageSize optional.Int32
}

func (a *V1ApiService) DashboardGetDashboardInformationServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32, localVarOptionals *V1ApiDashboardGetDashboardInformationServiceGroupInstanceNoGetOpts) (ResponseVoGetOpenApiDashboardInformationResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetOpenApiDashboardInformationResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dashboard/getDashboardInformation/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNo.IsSet() {
		localVarQueryParams.Add("pageNo", parameterToString(localVarOptionals.PageNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param createImportJob Create Import Job 파라미터
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) ImportCreateDataImportJobServiceGroupInstanceNoPost(ctx context.Context, createImportJob CreateImportJob, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/import/createDataImportJob/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &createImportJob

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) ImportGetBucketListServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/import/getBucketList/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No
 * @param optional nil or *V1ApiImportGetDataImportHistoryServiceGroupInstanceNoGetOpts - Optional Parameters:
     * @param "PageNo" (optional.Int32) -  Page No
     * @param "PageSize" (optional.Int32) -  Page Size

@return ResponseVoGetImportHistoryListResponseVo
*/

type V1ApiImportGetDataImportHistoryServiceGroupInstanceNoGetOpts struct { 
	PageNo optional.Int32
	PageSize optional.Int32
}

func (a *V1ApiService) ImportGetDataImportHistoryServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32, localVarOptionals *V1ApiImportGetDataImportHistoryServiceGroupInstanceNoGetOpts) (ResponseVoGetImportHistoryListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetImportHistoryListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/import/getDataImportHistory/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNo.IsSet() {
		localVarQueryParams.Add("pageNo", parameterToString(localVarOptionals.PageNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) ImportStopDataImportJobServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/import/stopDataImportJob/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param getElasticsearchMonitoringData ES 모니터링 데이터 조회 파라미터
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoQueryMultipleDataResponseVo
*/
func (a *V1ApiService) MonitoringGetElasticsearchMonitoringDataServiceGroupInstanceNoPost(ctx context.Context, getElasticsearchMonitoringData GetElasticsearchMonitoringData, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoQueryMultipleDataResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoQueryMultipleDataResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/getElasticsearchMonitoringData/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &getElasticsearchMonitoringData

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param getOsMonitoringData OS 모니터링 데이터 조회 파라미터
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoQueryMultipleDataResponseVo
*/
func (a *V1ApiService) MonitoringGetOsMonitoringDataServiceGroupInstanceNoPost(ctx context.Context, getOsMonitoringData GetOsMonitoringData, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoQueryMultipleDataResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoQueryMultipleDataResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/getOsMonitoringData/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &getOsMonitoringData

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param createSnapshot Snapshot 생성 파라미터
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) SnapshotCreateSnapshotServiceGroupInstanceNoPost(ctx context.Context, createSnapshot CreateSnapshot, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapshot/createSnapshot/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &createSnapshot

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoGetObjectStorageBucketListResponseVo
*/
func (a *V1ApiService) SnapshotGetBucketListServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoGetObjectStorageBucketListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetObjectStorageBucketListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapshot/getBucketList/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No
 * @param optional nil or *V1ApiSnapshotGetSnapshotHistoryServiceGroupInstanceNoGetOpts - Optional Parameters:
     * @param "PageNo" (optional.Int32) -  pageNo
     * @param "PageSize" (optional.Int32) -  pageSize

@return ResponseVoSnapshotHistoryListResponseVo
*/

type V1ApiSnapshotGetSnapshotHistoryServiceGroupInstanceNoGetOpts struct { 
	PageNo optional.Int32
	PageSize optional.Int32
}

func (a *V1ApiService) SnapshotGetSnapshotHistoryServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32, localVarOptionals *V1ApiSnapshotGetSnapshotHistoryServiceGroupInstanceNoGetOpts) (ResponseVoSnapshotHistoryListResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoSnapshotHistoryListResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapshot/getSnapshotHistory/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PageNo.IsSet() {
		localVarQueryParams.Add("pageNo", parameterToString(localVarOptionals.PageNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param getSnapshotSchedulingHistory Snapshot Scheduling 이력 조회
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoGetSnapshotSchedulingHistoryResponseVo
*/
func (a *V1ApiService) SnapshotGetSnapshotSchedulingHistoryServiceGroupInstanceNoPost(ctx context.Context, getSnapshotSchedulingHistory GetSnapshotSchedulingHistory, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoGetSnapshotSchedulingHistoryResponseVo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoGetSnapshotSchedulingHistoryResponseVo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapshot/getSnapshotSchedulingHistory/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &getSnapshotSchedulingHistory

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) SnapshotReleaseSnapshotSchedulingServiceGroupInstanceNoGet(ctx context.Context, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapshot/releaseSnapshotScheduling/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param setSnapshotScheduling Snapshot Scheduling 설정
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) SnapshotSetSnapshotSchedulingServiceGroupInstanceNoPost(ctx context.Context, setSnapshotScheduling SetSnapshotScheduling, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapshot/setSnapshotScheduling/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &setSnapshotScheduling

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
V1ApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param updateAPIAuthenticationKey API 인증키 설정 파라미터
 * @param serviceGroupInstanceNo serviceGroupInstanceNo
 * @param xNCPREGIONNO Region No

@return ResponseVoBoolean
*/
func (a *V1ApiService) SnapshotUpdateAPIAuthenticationKeyServiceGroupInstanceNoPost(ctx context.Context, updateAPIAuthenticationKey UpdateApiAuthenticationKey, serviceGroupInstanceNo string, xNCPREGIONNO int32) (ResponseVoBoolean, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseVoBoolean
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapshot/updateAPIAuthenticationKey/{serviceGroupInstanceNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceGroupInstanceNo"+"}", fmt.Sprintf("%v", serviceGroupInstanceNo), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["X-NCP-REGION_NO"] = parameterToString(xNCPREGIONNO, "")
	// body params
	localVarPostBody = &updateAPIAuthenticationKey

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)

	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}

		return localVarReturnValue, localVarHttpResponse, newErr
	}

	if err := json.Unmarshal(localVarBody, &localVarReturnValue); err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

